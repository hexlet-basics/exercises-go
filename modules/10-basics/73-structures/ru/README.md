Go — язык со строгой типизацией и поддержкой объектного стиля, но без привычного `class`. Вместо этого используется сочетание структур (для хранения состояния) и методов (для поведения).

Это позволяет создавать объекты, инкапсулирующие данные и операции над ними — как в ООП, но проще и прямолинейнее.

## Объявление структуры

Структура — это пользовательский тип, состоящий из набора полей:

```go
type User struct {
	Name string
	Age  int
}
```

Структура `User` описывает сущность с двумя полями: `Name` (строка) и `Age` (целое число). Теперь `User` — это новый тип данных, который можно использовать, как любой другой. Чтобы создать значение структуры, используют литерал структуры.

```go
// var user User;
user := User{
	Name: "Alice",
	Age:  30,
}
```

К полям структуры можно обращаться напрямую:

```go
fmt.Println(user.Name) // Alice
user.Age = 31
```

## Методы

Go позволяет определять методы — это функции, привязанные к типу (например, к структуре). Они выглядят как обычные функции, но с особым параметром — приёмником (receiver), который указывается в скобках перед именем функции. Обращаться к нему можно так же как и любым другим параметрам:

```go
func (u User) Greet() string {
	return "Hi, I'm " + u.Name
}
```

Этот метод можно вызвать на экземпляре структуры:

```go
user := User{Name: "Alice", Age: 30}
fmt.Println(user.Greet()) // Hi, I'm Alice
```

## Где описывать методы?

Методы определяются вне структуры, но обязательно в том же пакете. В теле самой структуры можно определить только поля. Вот правильная структура:

```go
package main

import "fmt"

type User struct {
	Name string
	Age  int
}

func (u User) Greet() string {
	return "Hi, I'm " + u.Name
}

func main() {
	user := User{Name: "Bob"}
	fmt.Println(user.Greet())
}
```

Порядок не имеет значения — метод может быть описан до или после использования структуры. Главное — чтобы тип, к которому он относится, был определён в том же пакете.

## Передача структуры в функцию

Со структурами работают не только методы. Как и любой другой тип, структуру можно передавать в обычные функции. Это позволяет использовать её как единое значение, передавая сразу связанный набор данных.

```go
func PrintAge(u User) {
	fmt.Println("Возраст:", u.Age)
}
```

Функция `PrintAge` получает структуру `User` и работает с её полями. При этом структура передаётся **по значению**, то есть копируется. Если изменить ее внутри функции, то изменится копия — оригинал останется без изменений. Такая же логика действует и для методов.

```go
func ChangeName(u User) {
	u.Name = "Неизвестно"
}

func (u User) ResetName() {
	u.Name = "Без имени"
}

func main() {
	user := User{Name: "Alice", Age: 30}

	ChangeName(user)
	fmt.Println(user.Name) // Alice — не изменилось

	user.ResetName()
	fmt.Println(user.Name) // Alice — не изменилось
}
```

Чтобы изменения применялись к оригинальной структуре, нужно передавать указатель. Это мы научимся делать в следующих уроках.
