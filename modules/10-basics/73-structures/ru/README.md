Go — язык со строгой типизацией и поддержкой объектного стиля, но без привычного `class`. Вместо этого используется сочетание структур (для хранения состояния) и методов (для поведения).

Это позволяет создавать объекты, инкапсулирующие данные и операции над ними — как в ООП, но проще и прямолинейнее.

## Объявление структуры

Структура — это пользовательский тип, состоящий из набора полей:

```go
type User struct {
	Name string
	Age  int
}
```

Структура `User` описывает сущность с двумя полями: `Name` (строка) и `Age` (целое число). Теперь `User` — это новый тип данных, который можно использовать, как любой другой. Чтобы создать значение структуры, используют литерал структуры.

```go
// var user User;
user := User{
	Name: "Alice",
	Age:  30,
}
```

К полям структуры можно обращаться напрямую:

```go
fmt.Println(user.Name) // Alice
user.Age = 31
```

## Методы

Go позволяет определять методы — это функции, привязанные к типу (например, к структуре). Они выглядят как обычные функции, но с особым параметром — приёмником (receiver), который указывается в скобках перед именем функции. Обращаться к нему можно так же как и любым другим параметрам:

```go
func (u User) Greet() string {
	return "Hi, I'm " + u.Name
}
```

Этот метод можно вызвать на экземпляре структуры:

```go
user := User{Name: "Alice", Age: 30}
fmt.Println(user.Greet()) // Hi, I'm Alice
```

## Где описывать методы?

Методы определяются вне структуры, но обязательно в том же пакете. В теле самой структуры можно определить только поля. Вот правильная структура:

```go
package main

import "fmt"

type User struct {
	Name string
}

func (u User) Greet() string {
	return "Hi, I'm " + u.Name
}

func main() {
	user := User{Name: "Bob"}
	fmt.Println(user.Greet())
}
```

Порядок не имеет значения — метод может быть описан до или после использования структуры. Главное — чтобы тип, к которому он относится, был определён в том же пакете.
