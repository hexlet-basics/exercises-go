
В Go представлено много числовых типов данных: *uint*, *uint8*, *uint16*, *uint32*, *uint64*, *int*, *int8*, *int16*, *int32*, *int64*, *float32*, *float64*, *complex64*, *complex128*. Зачем же столько типов для чисел? Одна из главных особенностей Go — это кроссплатформенность. Пишется один код, который компилируется и запускается на любой архитектуре процессора. В своем коде предпочтительнее использовать *int* и *uint*, так как они являются архитектурно-независимыми: в момент компиляции принимают значение 32 или 64 битов под процессор.

На самом деле вам не нужно запоминать все эти типы. В ежедневной работе вы будете сталкиваться с:
- *int* — основной кросплатформенный тип целых чисел, может быть отрицательным
- *int64* нужен для больших чисел из внешних систем. Например, ID в СУБД имеет тип *bigint*. Чтобы правильно распарсить такой ID, используется *int64*
- *float64* — число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max`, определяющая наибольшее число, принимает аргументы в виде *float64*

В Go имеется стандартный набор арифметических операций:

```go
x := 10
y := 5

// сложение
x + y // 15

// вычитание
x - y // 5

// деление
x / y // 2

// умножение
x * y // 50
```

Любые операции осуществляются только над числами одинакового типа:

```go
x := 5.05
y := 10

x + y // invalid operation: x + y (mismatched types float64 and int)
```

Чтобы осуществить сложение из прошлого примера, нам нужно конвертировать значения к одному типу

```go
x := 5.05
y := 10

x + float64(y) // 15.05
```

Числовые типы конвертируются без проблем между собой, однако есть нюансы, о которых стоит помнить:

```go
// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer

x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```

Приведенные выше примеры вызовут ошибки компиляции, поэтому вам не удастся «выстрелить себе в ногу». Однако существуют способы обмануть компилятор, и тогда вы получите неявное поведение в коде:

```go
a, _ := strconv.Atoi("-42")

// ошибки компиляции нет, но число было преобразовано в положительное путем прибавления MAX_UINT+1. MAX_UINT = 18446744073709551615
x := uint(a) // 18446744073709551574

a, _ := strconv.Atoi("5.05")

// ошибки компиляции нет, но значение всегда будет равно 0
x := int(a) // 0
```
