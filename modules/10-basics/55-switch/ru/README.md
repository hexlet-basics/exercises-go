В Go, кроме привычного `if`, есть ещё одна конструкция ветвления — `switch`. Она используется для выбора одного из нескольких возможных путей выполнения кода. На первый взгляд `switch` в Go похож на аналогичную конструкцию из других языков (например, C или Java), но его поведение отличается в важных деталях.

```go
x := 10

switch x {
case 10:
	fmt.Println("case 10")
default:
	fmt.Println("default case")
}
```

**Вывод:**

```go
case 10
```

В этом примере `x` сравнивается с каждым `case`. Как только находится совпадение, выполняется соответствующий блок, и `switch` завершается автоматически — писать `break` не нужно. Кроме того, `default` не обязан идти последним — он всегда выполняется в последнюю очередь, если не было совпадений.

Можно использовать switch без выражения. В этом случае он работает как if-else if, проверяя условия по порядку:

```go
x := 10

switch {
case x < 0:
	fmt.Println("negative")
case x == 0:
	fmt.Println("zero")
case x > 0:
	fmt.Println("positive")
}
```

**Вывод:**

```text
positive
```

Такой вариант удобен, когда нужно проверить набор условий, а не одно значение.

## Ключевое слово fallthrough

В Go по умолчанию не происходит проваливания в следующий case, как это бывает в других языках. Но если вы хотите принудительно продолжить выполнение следующего блока, можно использовать `fallthrough`:

```go
x := 10

switch {
case x == 10:
	fmt.Println("equal 10 case")
	fallthrough
case x < 20:
	fmt.Println("less than 20 case")
}
```

**Вывод:**

```go
equal 10 case
less than 20 case
```

Ключевое слово `fallthrough` всегда выполняет следующий case, даже если его условие не подходит. Это может привести к неожиданному поведению, поэтому используется редко и осознанно.
