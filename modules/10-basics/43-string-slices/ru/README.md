Работая со строками, мы часто сталкиваемся с задачей: извлечь часть строки. Например, получить год из даты, имя из полного ФИО или последние 4 цифры из номера карты. В Go для этого используются срезы (slice).

Срез строки — это операция извлечения подстроки по индексам:

```go
s := "12-08-2034"
year := s[6:10]
fmt.Println(year) // "2034"
```

Здесь `s[6:10]` означает: взять байты с позиции 6 включительно по 10 не включительно. Результатом будет строка, то есть срез строки это всегда строка, даже если она состоит из чисел.

> Строки в Go — это последовательности байт, а не символов. Поэтому такой способ безопасен только для ASCII (латиница, цифры, знаки). Подробнее об этом ниже.

## Открытые границы

Можно опускать начальный или конечный индекс:

```go
s := "Hexlet"

fmt.Println(s[:3])  // "Hex" — от начала до 3 (не включительно)
fmt.Println(s[3:])  // "let" — с 3 до конца
fmt.Println(s[:])   // "Hexlet" — вся строка
```

## Многобайтовые символы

В Go строки — это байты. Это означает, что при работе с символами, занимающими больше одного байта (например, кириллица или emoji), срез может «разрезать» символ внутри:

```go
s := "привет"
fmt.Println(s[:2]) // выведет некорректные символы
```

Чтобы корректно извлекать символы, а не байты, строку можно временно преобразовать в массив рун (rune — тип для хранения символов в Go):

```go
s := "привет"
r := []rune(s)             // преобразование строки в массив символов
fmt.Println(string(r[:3])) // "при"
```

> Мы ещё не изучали массивы (срезы), но []rune(s) превращает строку в набор символов. Такой подход безопасен для юникода. Подробнее мы рассмотрим коллекции в будущих уроках.

## Примеры использования

```go
email := "user@example.com"
domain := email[5:] // "@example.com"

card := "1234567812345678"
tail := card[12:]   // "5678"
```
