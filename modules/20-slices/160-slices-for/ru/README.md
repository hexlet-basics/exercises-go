Циклы в Go — основной инструмент для обхода срезов и работы с их элементами. Для этого можно использовать классический for с индексом, который даёт полный контроль и позволяет напрямую изменять значения, или лаконичный `range`, упрощающий перебор элементов и повышающий читаемость кода.

## Обход среза по индексу

```go
names := []string{"Alice", "Bob", "Charlie"}

for i := 0; i < len(names); i++ {
	fmt.Println(names[i])
}
```

- Полный контроль над индексами
- Подходит для изменения значений:

```go
nums := []int{1, 2, 3}

for i := 0; i < len(nums); i++ {
	nums[i] *= 2
}
fmt.Println(nums) // [2 4 6]
```

## Обход среза с помощью `range`

```go
langs := []string{"Go", "Rust", "Python"}

for i, lang := range langs {
	fmt.Printf("langs[%d] = %s\n", i, lang)
}
```

- `range` возвращает индекс и копию значения.
- Упрощает синтаксис.
- Хорошо читается.
- Подходит для большинства задач обхода

Если не нужен индекс:

```go
for _, lang := range langs {
	fmt.Println(lang)
}
```

Если не нужно значение:

```go
for i := range langs {
	fmt.Println(i)
}
```

## Изменение значений в `range`

Важно: переменная `lang` — это **копия** значения. Изменения не повлияют на оригинальный срез:

```go
for _, lang := range langs {
	lang = strings.ToUpper(lang) // изменится копия, не оригинал
}
fmt.Println(langs) // ["Go" "Rust" "Python"]
```

Чтобы изменить элементы, нужно использовать индекс:

```go
for i := range langs {
	langs[i] = strings.ToUpper(langs[i])
}
fmt.Println(langs) // ["GO" "RUST" "PYTHON"]
```

## Вывод

| Способ        | Изменение значений | Контроль над порядком | Краткость |
|---------------|---------------------|------------------------|-----------|
| По индексу    | Да                  | Да                     | Нет       |
| Через `range` | Только через индекс | Нет                    | Да        |

Цикл `range` — стандарт для чтения, `for` с индексом — для изменения.
