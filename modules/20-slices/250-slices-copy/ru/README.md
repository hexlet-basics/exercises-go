Срезы (`slices`) в Go передаются по значению, но содержат **указатель на данные**, поэтому простое присваивание приводит к совместному использованию одной и той же области памяти. Изменения в одном срезе могут повлиять на другой:

```go
a := []int{1, 2, 3}
b := a
b[0] = 100

// изменился и a
fmt.Println(a) // => [100 2 3]
fmt.Println(b) // => [100 2 3]
```

Чтобы избежать таких побочных эффектов, нужно **явно копировать содержимое среза**.

## Копирование с помощью slices.Clone()

Стандартный пакет `slices` предлагает удобную функцию `Clone()`, которая создаёт новый срез с тем же содержимым, не изменяя оригинал:

```go
import "slices"

original := []int{1, 2, 3}
clone := slices.Clone(original)

clone[0] = 100
fmt.Println(original) // => [1 2 3]
fmt.Println(clone)    // => [100 2 3]
```

Функция `Clone` всегда создаёт **новый срез** с собственной памятью.

## Частичное копирование: slices.Copy()

Если нужно скопировать данные из одного среза в другой, используйте `slices.Copy()`:

```go
import "slices"

src := []int{1, 2, 3}
dst := make([]int, 2)
slices.Copy(dst, src)

fmt.Println(dst) // => [1 2]
```

Копируется столько элементов, сколько поместится в `dst`.

## Почему простого присваивания недостаточно

Присваивание среза копирует только структуру (`указатель`, `длина`, `вместимость`), но не сам массив. Это значит, что оба среза будут ссылаться на один и тот же набор данных:

```go
a := []string{"hello", "world"}
b := a

b[0] = "hi"
// a изменился!
fmt.Println(a) // => [hi world]
fmt.Println(b) // => [hi world]
```

## Пример: безопасное клонирование перед модификацией

```go
import "slices"

func transform(data []int) []int {
	clone := slices.Clone(data)
	for i := range clone {
		clone[i] *= 2
	}
	return clone
}

func main() {
	values := []int{1, 2, 3}
	newValues := transform(values)

	fmt.Println(values)    // [1 2 3]
	fmt.Println(newValues) // [2 4 6]
}
```

## Рекомендации

- Используйте `slices.Clone()` для создания независимой копии среза.
- Для частичного копирования применяйте `slices.Copy()`.
- Избегайте простого присваивания (`b := a`), если ожидается независимость данных.
