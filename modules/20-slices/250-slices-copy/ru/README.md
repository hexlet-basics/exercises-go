Срезы (`slices`) в Go передаются по значению, но содержат **указатель на данные**, поэтому простое присваивание приводит к совместному использованию одной и той же области памяти. Изменения в одном срезе могут повлиять на другой:

```go
a := []int{1, 2, 3}
b := a
b[0] = 100

fmt.Println(a) // [100 2 3] — изменился и a
```

Чтобы избежать таких побочных эффектов, нужно **явно копировать содержимое среза**.

## Копирование с помощью `slices.Clone()`

Современный Go предлагает удобную функцию `slices.Clone()`, которая создаёт новый срез с тем же содержимым, не изменяя оригинал:

```go
import "slices"

original := []int{1, 2, 3}
clone := slices.Clone(original)

clone[0] = 100
fmt.Println(original) // [1 2 3]
fmt.Println(clone)    // [100 2 3]
```

`Clone` всегда создаёт **новый срез** с собственной памятью.

## Частичное копирование: `slices.Copy()`

Если нужно скопировать данные из одного среза в другой, используйте `slices.Copy()`:

```go
import "slices"

src := []int{1, 2, 3}
dst := make([]int, 2)
slices.Copy(dst, src)

fmt.Println(dst) // [1 2]
```

Копируется столько элементов, сколько поместится в `dst`.

## Почему недостаточно `b := a`

Присваивание среза копирует только структуру (`указатель`, `длина`, `вместимость`), но не сам массив. Это значит, что оба среза будут ссылаться на один и тот же набор данных:

```go
a := []string{"hello", "world"}
b := a

b[0] = "hi"
fmt.Println(a) // [hi world] — a изменился!
```

## Пример: безопасное клонирование перед модификацией

```go
import "slices"

func transform(data []int) []int {
	clone := slices.Clone(data)
	for i := range clone {
		clone[i] *= 2
	}
	return clone
}

func main() {
	values := []int{1, 2, 3}
	newValues := transform(values)

	fmt.Println(values)    // [1 2 3]
	fmt.Println(newValues) // [2 4 6]
}
```

## Рекомендации

- Используйте **`slices.Clone()`** для создания независимой копии среза.
- Для частичного копирования применяйте **`slices.Copy()`**.
- Избегайте простого присваивания (`b := a`), если ожидается независимость данных.
