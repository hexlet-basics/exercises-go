## Копирование срезов в Go

Срезы (`slices`) в Go передаются по значению, но содержат **указатель на данные**, поэтому простое присваивание приводит к совместному использованию одной и той же области памяти. Изменения в одном срезе могут повлиять на другой:

~~~go
a := []int{1, 2, 3}
b := a
b[0] = 100

fmt.Println(a) // [100 2 3] — изменился и a
~~~

Чтобы избежать таких побочных эффектов, нужно **явно копировать содержимое среза**.

---

## Копирование с помощью `copy()`

Go предоставляет встроенную функцию `copy(dst, src)`, которая копирует данные из `src` в `dst`. Оба аргумента должны быть срезами одного типа.

~~~go
original := []int{1, 2, 3}
clone := make([]int, len(original))
copy(clone, original)

clone[0] = 100
fmt.Println(original) // [1 2 3] — не изменился
fmt.Println(clone)    // [100 2 3]
~~~

> `copy()` возвращает количество скопированных элементов, равное `min(len(dst), len(src))`

Если длина целевого среза меньше длины источника, будет скопирована только часть:

~~~go
src := []int{1, 2, 3}
dst := make([]int, 2)
copy(dst, src)

fmt.Println(dst) // [1 2]
~~~

---

## Копирование с помощью `append()`

Иногда недостаточно просто присвоить срез другому — особенно если важно, чтобы изменения в одном не затрагивали другой. Такое бывает, например, при обработке данных в разных функциях, кэшировании, или когда нужно сохранить исходное состояние. В таких случаях нужно создать **независимую копию**, и `append()` предоставляет удобный способ это сделать.

~~~go
original := []int{1, 2, 3}
clone := append([]int(nil), original...)
~~~

Здесь создаётся новый пустой срез `[]int(nil)`, и в него добавляются все элементы `original`. Это гарантирует, что новый срез будет **собственной копией**, а не ссылкой на исходные данные.

Этот приём особенно удобен в однострочных выражениях, например, при передаче копии куда-то:

~~~go
sendData(append([]int(nil), inputData...))
~~~

---

## Почему недостаточно просто `b := a`

Присваивание среза копирует только структуру (`указатель`, `длина`, `вместимость`), но не сам массив. Это дешёвая операция, но оба среза будут ссылаться на **один и тот же массив**:

~~~go
a := []string{"hello", "world"}
b := a

b[0] = "hi"
fmt.Println(a) // [hi world] — a изменился!
~~~

---

## Рекомендации

- Если вы хотите **создать независимую копию**, используйте `copy()` или `append()`.
- Для копирования с предопределённой длиной — используйте `make()` и `copy()`.
- Для коротких копий, временных значений, передачи в функции — удобно использовать `append([]T(nil), s...)`.

---

## Пример: безопасное клонирование перед модификацией

~~~go
func transform(data []int) []int {
	clone := append([]int(nil), data...)
	for i := range clone {
		clone[i] *= 2
	}
	return clone
}

func main() {
	values := []int{1, 2, 3}
	newValues := transform(values)

	fmt.Println(values)    // [1 2 3]
	fmt.Println(newValues) // [2 4 6]
}
~~~

---

## Вывод

Копирование срезов — важный инструмент управления памятью и безопасностью в Go. Будьте внимательны при работе со срезами: присваивание копирует ссылку, а не данные. Чтобы избежать побочных эффектов, используйте `copy()` или `append()` для создания полной копии данных.

