Массив — это коллекция однотипных значений фиксированной длины:

```go
nums := [5]int{}
```

Длина массива указывается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:

```go
nums := [5]int{} // [0, 0, 0, 0, 0]

// длинная инициализация
var nums [5]int // [0, 0, 0, 0, 0]
```

При попытке инициализации элементов за границей массива выходит ошибка компиляции:

```go
nums := [1]int{1, 2} // array index 1 out of bounds [0:1]
```

Чтение и запись элементов массива происходит через квадратные скобки:

```go
nums := [3]int{1, 2, 3}

fmt.Println(nums[1]) // 2

nums[2] = 33

fmt.Println(nums) // [1, 2, 33]
```

Нумерация элементов массива начинается с 0. При попытке чтения/записи элементов за границей массива выходит ошибка компиляции:

```go
words := [2]string{}

words[2] // invalid array index 2 (out of bounds for 2-element array)
```

Массивы в Go передаются по значению, следовательно, любое изменение внутри функции не влияет на исходный массив:

```go
package main

import (
	"fmt"
)

func main() {
	a := [3]int{1, 2, 3}

	modifyArr(a)

	fmt.Println(a) // 1, 2, 3
}

func modifyArr(nums [3]int) {
	nums[0] = 35
}
```

В Go есть встроенная функция `len()`, которая возвращает длину массива:

```go
fmt.Println(len([5]int{1, 2, 3})) // 5
fmt.Println(len([10]int{}))       // 10
```

Так как массивы инициализируются с фиксированной длинной, то функция `len()` всегда возвращает одно и то же значение.
