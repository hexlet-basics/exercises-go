---

name: Копирование слайсов
theory: |

  Допустим, в вашей функции происходят изменения элементов, но вы не хотите затронуть входной слайс. В языке есть встроенная функция `func copy(dst, src []Type) int`, которая копирует слайс `src` в слайс `dst` и возвращает кол-во скопированных элементов:

  ```go
  nums := []int{1,2,3,4,5}

  // важно инициализировать слайс той же длины
  numsCp := make([]int, len(nums))

  copy(numsCp, nums)

  fmt.Println(numsCp) // [1,2,3,4,5]
  ```

  Почему мы не можем просто перезаписать слайс в другую переменную и изменять ее? Как и с функциями, при присваивании слайса к переменной, копируется только длина и вместимость, но массив передается по ссылке:

  ```go
  nums := []int{1,2,3,4,5}

  numsCp := nums

  // исходный слайс nums тоже будет изменен
  numsCp[0] = 10

  fmt.Println(nums) // [10,2,3,4,5]
  ```

  Существует распространенная ошибка, когда пытаются скопировать слайсы различной длины. В этом случае элементы, выходящие за рамки слайса `dst`, не будут скопированы:

  ```go
  nums := []int{1, 2, 3, 4, 5}

  // создали слайс с длиной 0
  numsCp := make([]int, 0)

  // при копировании в пустой слайс ничего не произойдет
  copy(numsCp, nums)

  fmt.Println(numsCp) // []
  ```

instructions: |

  Реализуйте функцию `IntsCopy(src []int, maxLen int) []int`, которая создает копию слайса `src` с длиной `maxLen`. Если `maxLen` равен нулю или отрицательный, то функция возвращает пустой слайс `[]int{}`. Если `maxLen` больше длины `src`, то возвращается полная копия `src`.


tips:
  - |
    [The Go Programming Language Specification — Appending to and copying slices](https://golang.org/ref/spec#Appending_and_copying_slices)
