
Вот и подошло время познакомиться с самой сильной стороной языка Go — горутинами. Горутины — это легковесные потоки, которые реализуют конкурентное программирование в Go. Их называют *легковесными потоками*, потому что они управляются рантаймом языка, а не операционной системой. Стоимость переключения контекста и расход памяти намного ниже, чем у потоков ОС. Следовательно, для Go — не проблема поддерживать одновременно десятки тысяч горутин.

Запустить функцию в горутине — супер легко. Для этого достаточно написать слово `go` перед вызовом функции:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// выведет сообщение в горутине
	go fmt.Println("Hello concurrent world")

	// если не подождать, то программа закончится, не успев, вывести сообщение
	time.Sleep(100 * time.Millisecond)
}
```

При написании конкурентного кода возникают новые моменты, которые нужно учитывать: состояние гонки, блокировки, коммуникация между горутинами. Пример программы, которая работает не так, как ожидается:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
		}()
	}

	time.Sleep(100 * time.Millisecond)
}
```

Сперва может показаться, что должны вывестись числа от 0 до 4, но на самом деле вывод будет следующим:

```go
5
5
5
5
5
```

Все потому что *i* передается в общем скоупе, следовательно, когда горутины будут выполняться, цикл уже закончится и *i* будет равно *5*. В данном случае нужно передать копию *i*:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	for i := 0; i < 5; i++ {
		go func(i int) {
			fmt.Println(i)
		}(i)
	}

	time.Sleep(100 * time.Millisecond)
}
```

Вывод:

```go
0
4
3
1
2
```

Также можно заметить, что числа вывелись не в порядке вызова. Горутины выполняются независимо и не гарантируют порядка. При необходимости последовательность в выполнении придется реализовывать самостоятельно.
